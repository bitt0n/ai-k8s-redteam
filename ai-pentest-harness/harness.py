#!/usr/bin/env python3
import os, sys, argparse, yaml, re, json, time, pathlib
import regex as cregex
from typing import Dict, Any, List
from rich import print

def load_cases(path: str) -> List[Dict[str, Any]]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

# --- Adapters ---
def call_http_adapter(prompt: str, endpoint: str) -> str:
    """Generic HTTP adapter expecting POST {prompt: str} -> {output: str}"""
    import requests
    resp = requests.post(endpoint, json={"prompt": prompt}, timeout=60)
    resp.raise_for_status()
    data = resp.json()
    # Try common fields
    for key in ("output", "text", "completion", "response"):
        if key in data:
            return data[key]
    # Fallback: best-effort
    return json.dumps(data, ensure_ascii=False)

def call_offline_adapter(prompt: str) -> str:
    """Deterministic offline mode for labs without a model; returns the prompt back."""
    return f"[offline-adapter echo] {prompt[:4000]}"

ADAPTERS = {
    "http": call_http_adapter,
    "offline": lambda p: call_offline_adapter(p),
}

def check_result(text: str, checks: Dict[str, Any]) -> Dict[str, Any]:
    res = {"pass": True, "reasons": []}
    mmr = checks.get("must_not_match_regex") or []
    mmc = checks.get("must_not_contain") or []
    mr  = checks.get("must_match_regex") or []
    mc  = checks.get("must_contain") or []

    for pat in mmr:
        if cregex.search(pat, text):
            res["pass"] = False
            res["reasons"].append(f"Matched forbidden regex: {pat}")

    for s in mmc:
        if s in text:
            res["pass"] = False
            res["reasons"].append(f"Contained forbidden string: {s}")

    for pat in mr:
        if not cregex.search(pat, text):
            res["pass"] = False
            res["reasons"].append(f"Did not match required regex: {pat}")

    for s in mc:
        if s not in text:
            res["pass"] = False
            res["reasons"].append(f"Did not contain required string: {s}")

    return res

def main():
    ap = argparse.ArgumentParser(description="AI Pentest Harness")
    ap.add_argument("--cases", required=True, help="Path to YAML testcases")
    ap.add_argument("--adapter", choices=ADAPTERS.keys(), default="offline", help="Model adapter")
    ap.add_argument("--endpoint", default=os.environ.get("MODEL_ENDPOINT_URL", ""), help="HTTP adapter endpoint")
    ap.add_argument("--sleep", type=float, default=0.0, help="Delay between cases (sec)")
    args = ap.parse_args()

    cases = load_cases(args.cases)
    total, fails = 0, 0

    for case in cases:
        total += 1
        cid = case.get("id", f"case-{total:03d}")
        prompt = case["prompt"]
        checks = case.get("checks", {})
        print(f"\n[bold cyan]Running {cid}[/] â€” {case.get('objective','(no objective)')}")
        if args.adapter == "http" and not args.endpoint:
            print("[red]No endpoint set for HTTP adapter. Use --endpoint or MODEL_ENDPOINT_URL.[/]")
            sys.exit(2)
        try:
            out = ADAPTERS[args.adapter](prompt, args.endpoint) if args.adapter == "http" else ADAPTERS[args.adapter](prompt)
        except Exception as e:
            print(f"[red]Adapter error:[/] {e}")
            fails += 1
            continue
        verdict = check_result(out, checks)
        if verdict["pass"]:
            print("[green]PASS[/]")
        else:
            print("[red]FAIL[/]")
            for r in verdict["reasons"]:
                print(f"  - {r}")
            fails += 1
        if args.sleep:
            import time as _t; _t.sleep(args.sleep)

    print(f"\n[bold]Summary:[/] total={total}, fails={fails}, pass={total - fails}")
    sys.exit(1 if fails else 0)

if __name__ == "__main__":
    main()
